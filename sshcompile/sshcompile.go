// 1bin / sshcompile
// MIT License Copyright(c) 2020 Hiroshi Shimamoto
// vim:set sw=4 sts=4:
package sshcompile

import (
    "io/ioutil"
    "log"
    "os"
    "path/filepath"
    "strings"

    "1bin/lib/f"
)

/*
 * This tool `sshcompile` generates .ssh/config file.
 * The sources for hosts should be placed under .ssh/hosts
 * and identity keys should be placed under .ssh/keys.
 */

var keyMap map[string]string = map[string]string{
    "hostname": "Hostname",
    "user": "User",
    "port": "Port",
    "identityfile": "IdentityFile",
    "proxycommand": "ProxyCommand",
    "proxyusefdpass": "ProxyUseFdpass",
    "stricthostkeychecking": "StrictHostKeyChecking",
    "userknownhostfile": "UserKnownHostFile",
    "serveraliveinterval": "ServerAliveInterval",
}
var keys []string = []string{
    "user", "hostname", "port", "identityfile",
    "proxycommand", "proxyusefdpass", "serveraliveinterval",
    "stricthostkeychecking", "userknownhostfile",
}

var sshdir string

type sshHost struct {
    Path string
    Name string
    KeyVal map[string]string
    ChildTop *sshHost
    Children []*sshHost
}

func newSshHost(path string, f os.FileInfo) *sshHost {
    host := &sshHost{
	Path: path,
	Name: f.Name(),
	KeyVal: map[string]string{},
	ChildTop: nil,
	Children: []*sshHost{},
    }
    if f.IsDir() {
	result := make(chan *sshHost, 16)
	go walk(path, result)
	for child := range result {
	    if child == nil {
		continue
	    }
	    if child.Name == "_top" {
		host.ChildTop = child
	    } else {
		host.Children = append(host.Children, child)
	    }
	}
	host.Path = ""
    }
    return host
}

func (host *sshHost)compile() []string {
    log.Printf("compiling %s\n", host.Name)
    if host.Path == "" { // must have children
	config := []string{}
	if host.ChildTop != nil {
	    config = append(config, host.ChildTop.compile()...)
	}
	for _, child := range host.Children {
	    config = append(config, child.compile()...)
	}
	return config
    }

    for line0 := range f.Lines(host.Path) {
	line := strings.TrimSpace(line0)
	if line == "" {
	    continue
	}
	a := strings.SplitN(line, " ", 2)
	if len(a) != 2 {
	    a = strings.SplitN(line, "\t", 2)
	    if len(a) != 2 {
		log.Printf("Badline: %s\n", line)
	    }
	}
	key := strings.TrimSpace(a[0])
	val := strings.TrimSpace(a[1])
	host.KeyVal[strings.ToLower(key)] = val
    }

    // check identityfile
    if privkey, ok := host.KeyVal["identityfile"]; ok {
	path := filepath.Join(sshdir, "keys", privkey)
	host.KeyVal["identityfile"] = path
	if _, err := os.Stat(path); err != nil {
	    log.Printf("IdentityFile check error: %v\n", err)
	    delete(host.KeyVal, "identityfile")
	}
    }

    // make entry
    config := []string{ "Host " + host.Name }
    for _, key := range keys {
	if val, ok := host.KeyVal[key]; ok {
	    line := "  " + keyMap[key] + " " + val
	    config = append(config, line)
	}
    }
    return config
}

func walk(dir string, result chan<- *sshHost) {
    defer close(result)
    files, err := ioutil.ReadDir(dir)
    if err != nil {
	log.Printf("ReadDir err: %v\n", err)
	return
    }
    for _, f := range files {
	path := filepath.Join(dir, f.Name())
	result <- newSshHost(path, f)
    }
}

func Run(args []string) {
    sshdir = filepath.Join(os.Getenv("HOME"), ".ssh")
    result := make(chan *sshHost, 16)
    hostsdir := filepath.Join(sshdir, "hosts")
    config := []string{
	// Banner
	"# THIS FILE WAS GENERATED BY COMPILE PROGRAM",
	"# DO NOT MODIFY DIRECTLY",
	"",
    }
    go walk(hostsdir, result)
    for host := range result {
	if host == nil {
	    continue
	}
	config = append(config, host.compile()...)
    }
    buf := []byte(strings.Join(config, "\n") + "\n")
    ioutil.WriteFile(filepath.Join(sshdir, "config"), buf, 0600)
}
